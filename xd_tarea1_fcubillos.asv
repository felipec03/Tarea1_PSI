clearvars
close all
clc

% Opciones del usuario
disp('A: Ingresar señales.')
disp('B: Señales aleatorias.')
opcion = input("Elige una opción: ", "s");

% Función para generar señales aleatorias
generarX = @(largo) -1 + 2*rand(1, largo);

if opcion == 'A'
    x_n = str2num(input("Ingrese la primera señal, separada por comas: ", "s"));
    h_n = str2num(input("Ingrese la respuesta al impulso, separada por comas: ", "s"));
else
    disp("Generando señales...");
    x_n = generarX(8); % Señal de largo 8
    h_n = generarX(6); % Filtro de largo 6 (múltiplo de 3)
    disp('x_n:'); disp(x_n);
    disp('h_n:'); disp(h_n);
end

% Convolución convencional con MATLAB
disp("Convolución de Matlab:");
y_matlab = conv(x_n, h_n);
disp('Resultado conv():');
disp(y_matlab);

% Convolución usando Winograd F(2,3)
disp("Convolución Winograd:");
y_winograd = winograd(x_n, h_n);
disp('Resultado Winograd:');
disp(y_winograd);

% Convolución usando matriz Toeplitz
disp("Convolución con matriz Toeplitz:");
tic
y_toeplitz = toep_convolucion(x_n, h_n)';
toc
disp('Resultado Toeplitz:');
disp(y_toeplitz);

% Medición de tiempos para diferentes tamaños
sizes = 2.^(3:13);
times_winograd = zeros(size(sizes));
times_toeplitz = zeros(size(sizes));

for i = 1:length(sizes)
    n = sizes(i);
    x = generarX(n);
    h = generarX(6); % Filtro de largo 6
    
    % Medir Winograd
    f_win = @() winograd(x, h);
    times_winograd(i) = timeit(f_win);
    
    % Medir Toeplitz
    f_toep = @() toep_convolucion(x, h);
    times_toeplitz(i) = timeit(f_toep);
end

%Graficar resultados
figure;
loglog(sizes, times_winograd, 'b-o', sizes, times_toeplitz, 'r-*');
xlabel('Tamaño de la señal x[n]');
ylabel('Tiempo de ejecución (s)');
legend('Winograd', 'Toeplitz');
title('Comparación de tiempos de convolución');
grid on;

function y_n = winograd(x, h)
    if mod(length(h), 3) ~= 0
        error('h debe tener longitud múltiplo de 3');
    end
    
    k = length(h) / 3; % Número de chunks de 3 elementos
    L = length(x) + length(h) - 1; % Longitud de salida
    y_n = zeros(1, L); % Inicializar salida
    
    for i = 0:k-1
        % Extraer el i-ésimo chunk de h (sin voltear todo h previamente)
        start_idx = 3*i + 1;
        end_idx = 3*(i+1);
        h_chunk = h(start_idx:end_idx);
        
        % Voltear el chunk individualmente
        h_chunk = fliplr(h_chunk); % <--- Corrección aquí
        
        % Calcular convolución Winograd para el chunk
        conv_i = winograd_ventana(x, h_chunk);
        
        % Desplazamiento corregido: 2*i en lugar de 3*i
        shift = 2*i; % <--- Corrección clave
        
        % Sumar el resultado desplazado
        y_n(shift + 1 : shift + length(conv_i)) = ...
            y_n(shift + 1 : shift + length(conv_i)) + conv_i;
    end
end

% funcion para largo x variable y h largo exactamente igual a 3
function y_n = winograd_ventana(x, h)
    % determinar padding
    pad_len = length(h) - 1;
    x_padded = [x, zeros(1, 2)];

    y_acum = [];
    expected_length = length(x) + length(h) - 1;
    num_windows = ceil(expected_length / 2);
    
    for i = 0:num_windows-1
        % Calculate starting position considering negative indices
        start = 2*i - pad_len + 1; % 1-based MATLAB index
        
        % Extract window with zero-padding for out-of-bounds
        window = zeros(1, 4);
        for j = 1:4
            pos = start + j - 1;
            if pos >= 1 && pos <= length(x_padded)
                window(j) = x_padded(pos);
            end
        end
        
        % Algoritmo F(2,3) de winograd
        m1 = (window(1) - window(3)) * h(1);
        m2 = (window(2) + window(3)) * sum(h)/2;
        m3 = (window(3) - window(2)) * (h(1) - h(2) + h(3))/2;
        m4 = (window(2) - window(4)) * h(end);
        
        y0 = m1 + m2 + m3;
        y1 = m2 - m3 - m4;
        
        % Resultado acumulado
        y_acum = [y_acum, y0, y1];
    end
    
    % Trim to the correct length
    y_n = y_acum(1:expected_length);
end

function y_n = toep_convolucion(x, h)
    % Computes convolution y = x * h using Toeplitz matrix formulation.
    len_x = length(x);
    len_h = length(h);

    % Create the first column for the Toeplitz matrix
    col = [h(:); zeros(len_x - 1, 1)];

    % Create the first row for the Toeplitz matrix
    row = [h(1), zeros(1, len_x - 1)];

    % Construct the full Toeplitz matrix
    H_full = toeplitz(col, row);

    % Extract the submatrix relevant for linear convolution
    H = H_full(1:(len_h + len_x - 1), 1:len_x);

    % Perform convolution via matrix multiplication
    y_n_col = H * x(:); % Ensure x is a column vector

    % Return as a row vector to match conv() and winograd_conv_corrected()
    y_n = y_n_col';
end